import logging
import traceback
from typing import Optional

from django.db import transaction

from .models import Court, Case, CaseSnapshot, CivilSearchJob
from .solon_scraper_adf import scrape_solon_civil_adf
from .normalizers import clean_solon_fields

logger = logging.getLogger(__name__)


def _ensure_job_case(job, client_name: Optional[str] = None) -> Case:
    """
    Ensure job.case exists. If missing, create or get a Case by client_name.
    Returns the Case instance.
    """
    if getattr(job, "case_id", None):
        return job.case

    name = (
        (client_name or "").strip()
        or getattr(job, "client_name", "",)
        or getattr(job, "case_name", "",)
    )
    if not name:
        name = "Χωρίς όνομα"

    case, _ = Case.objects.get_or_create(client_name=name)
    job.case = case
    try:
        job.save(update_fields=["case"])
    except Exception:
        job.save()
    return case


def _get_court_label(job) -> str:
    """
    Robustly derive the court label (human-friendly name) from the job.
    Handles both FK and plain id/storage.
    """
    try:
        # If it's a FK with .name
        v = getattr(job, "court", None)
        if v is not None:
            try:
                if hasattr(v, "name") and v.name:
                    return v.name
            except Exception:
                pass

        # Else try explicit court_id or a plain integer/string
        cid = getattr(job, "court_id", None)
        if cid is None:
            val = getattr(job, "court", None)
            if isinstance(val, (int, str)) and str(val).strip():
                cid = val

        if cid is not None and str(cid).strip():
            return Court.objects.get(id=int(cid)).name
    except Exception:
        logger.exception("Could not resolve court label from job id=%s", getattr(job, "id", None))

    return ""


def _has_meaningful_values(d: dict) -> bool:
    if not isinstance(d, dict) or not d:
        return False
    for v in d.values():
        if isinstance(v, str) and v.strip():
            return True
        if isinstance(v, (int, float)) and v:
            return True
    return False


def _run_job(job_id: int) -> None:
    job = CivilSearchJob.objects.select_for_update(of=("self",)).get(id=job_id)

    # Mark running
    job.status = "running"
    job.error = ""
    job.save(update_fields=["status", "error"])

    try:
        court_label = _get_court_label(job)
        gak_num = str(getattr(job, "gak_number", "")).strip()
        gak_year = int(getattr(job, "gak_year", 0))

        # Call scraper
        raw = scrape_solon_civil_adf(court_label, gak_num, gak_year)

        # Normalize to the field dict we display
        fields = clean_solon_fields(raw)

        # Create/ensure the Case and snapshot atomically
        with transaction.atomic():
            case = _ensure_job_case(job, getattr(job, "client_name", None))
            snap = CaseSnapshot.objects.create(case=case, data_json=fields)
            job.snapshot = snap

            # Decide status
            job.status = "done" if _has_meaningful_values(fields) else "no_results"
            job.save(update_fields=["snapshot", "status"])

    except Exception as e:
        tb = traceback.format_exc()
        logger.error("Job %s failed: %s\n%s", job_id, e, tb)
        job.status = "error"
        job.error = f"{e}\n{tb}"
        try:
            job.save(update_fields=["status", "error"])
        except Exception:
            job.save()


def start_civil_job(job_id: int) -> None:
    """
    Placeholder for async queue. Currently runs synchronously.
    """
    run_civil_job(job_id)


def run_civil_job(job_id: int) -> None:
    """
    Public entry point used by views.
    """
    _run_job(job_id)
